// This file is auto-generated by @hey-api/openapi-ts

import { type Options, Login, Users, Utils, Items, Private } from '../sdk.gen';
import { queryOptions, type UseMutationOptions, type DefaultError } from '@tanstack/react-query';
import type { LoginLoginAccessTokenData, LoginLoginAccessTokenError, LoginLoginAccessTokenResponse, LoginTestTokenData, LoginTestTokenResponse, LoginRecoverPasswordData, LoginRecoverPasswordError, LoginRecoverPasswordResponse, LoginResetPasswordData, LoginResetPasswordError, LoginResetPasswordResponse, LoginRecoverPasswordHtmlContentData, LoginRecoverPasswordHtmlContentError, LoginRecoverPasswordHtmlContentResponse, UsersReadUsersData, UsersCreateUserData, UsersCreateUserError, UsersCreateUserResponse, UsersDeleteUserMeData, UsersDeleteUserMeResponse, UsersReadUserMeData, UsersUpdateUserMeData, UsersUpdateUserMeError, UsersUpdateUserMeResponse, UsersUpdatePasswordMeData, UsersUpdatePasswordMeError, UsersUpdatePasswordMeResponse, UsersRegisterUserData, UsersRegisterUserError, UsersRegisterUserResponse, UsersDeleteUserData, UsersDeleteUserError, UsersDeleteUserResponse, UsersReadUserByIdData, UsersUpdateUserData, UsersUpdateUserError, UsersUpdateUserResponse, UtilsTestEmailData, UtilsTestEmailError, UtilsTestEmailResponse, UtilsHealthCheckData, ItemsReadItemsData, ItemsCreateItemData, ItemsCreateItemError, ItemsCreateItemResponse, ItemsDeleteItemData, ItemsDeleteItemError, ItemsDeleteItemResponse, ItemsReadItemData, ItemsUpdateItemData, ItemsUpdateItemError, ItemsUpdateItemResponse, PrivateCreateUserData, PrivateCreateUserError, PrivateCreateUserResponse } from '../types.gen';
import type { AxiosError } from 'axios';
import { client as _heyApiClient } from '../client.gen';

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseURL' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseURL: options?.baseURL || (options?.client ?? _heyApiClient).getConfig().baseURL } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [
        params
    ];
};

export const loginLoginAccessTokenQueryKey = (options: Options<LoginLoginAccessTokenData>) => createQueryKey('loginLoginAccessToken', options);

/**
 * Login Access Token
 * OAuth2 compatible token login, get an access token for future requests
 */
export const loginLoginAccessTokenOptions = (options: Options<LoginLoginAccessTokenData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await Login.loginAccessToken({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: loginLoginAccessTokenQueryKey(options)
    });
};

/**
 * Login Access Token
 * OAuth2 compatible token login, get an access token for future requests
 */
export const loginLoginAccessTokenMutation = (options?: Partial<Options<LoginLoginAccessTokenData>>): UseMutationOptions<LoginLoginAccessTokenResponse, AxiosError<LoginLoginAccessTokenError>, Options<LoginLoginAccessTokenData>> => {
    const mutationOptions: UseMutationOptions<LoginLoginAccessTokenResponse, AxiosError<LoginLoginAccessTokenError>, Options<LoginLoginAccessTokenData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await Login.loginAccessToken({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const loginTestTokenQueryKey = (options?: Options<LoginTestTokenData>) => createQueryKey('loginTestToken', options);

/**
 * Test Token
 * Test access token
 */
export const loginTestTokenOptions = (options?: Options<LoginTestTokenData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await Login.testToken({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: loginTestTokenQueryKey(options)
    });
};

/**
 * Test Token
 * Test access token
 */
export const loginTestTokenMutation = (options?: Partial<Options<LoginTestTokenData>>): UseMutationOptions<LoginTestTokenResponse, AxiosError<DefaultError>, Options<LoginTestTokenData>> => {
    const mutationOptions: UseMutationOptions<LoginTestTokenResponse, AxiosError<DefaultError>, Options<LoginTestTokenData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await Login.testToken({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const loginRecoverPasswordQueryKey = (options: Options<LoginRecoverPasswordData>) => createQueryKey('loginRecoverPassword', options);

/**
 * Recover Password
 * Password Recovery
 */
export const loginRecoverPasswordOptions = (options: Options<LoginRecoverPasswordData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await Login.recoverPassword({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: loginRecoverPasswordQueryKey(options)
    });
};

/**
 * Recover Password
 * Password Recovery
 */
export const loginRecoverPasswordMutation = (options?: Partial<Options<LoginRecoverPasswordData>>): UseMutationOptions<LoginRecoverPasswordResponse, AxiosError<LoginRecoverPasswordError>, Options<LoginRecoverPasswordData>> => {
    const mutationOptions: UseMutationOptions<LoginRecoverPasswordResponse, AxiosError<LoginRecoverPasswordError>, Options<LoginRecoverPasswordData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await Login.recoverPassword({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const loginResetPasswordQueryKey = (options: Options<LoginResetPasswordData>) => createQueryKey('loginResetPassword', options);

/**
 * Reset Password
 * Reset password
 */
export const loginResetPasswordOptions = (options: Options<LoginResetPasswordData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await Login.resetPassword({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: loginResetPasswordQueryKey(options)
    });
};

/**
 * Reset Password
 * Reset password
 */
export const loginResetPasswordMutation = (options?: Partial<Options<LoginResetPasswordData>>): UseMutationOptions<LoginResetPasswordResponse, AxiosError<LoginResetPasswordError>, Options<LoginResetPasswordData>> => {
    const mutationOptions: UseMutationOptions<LoginResetPasswordResponse, AxiosError<LoginResetPasswordError>, Options<LoginResetPasswordData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await Login.resetPassword({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const loginRecoverPasswordHtmlContentQueryKey = (options: Options<LoginRecoverPasswordHtmlContentData>) => createQueryKey('loginRecoverPasswordHtmlContent', options);

/**
 * Recover Password Html Content
 * HTML Content for Password Recovery
 */
export const loginRecoverPasswordHtmlContentOptions = (options: Options<LoginRecoverPasswordHtmlContentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await Login.recoverPasswordHtmlContent({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: loginRecoverPasswordHtmlContentQueryKey(options)
    });
};

/**
 * Recover Password Html Content
 * HTML Content for Password Recovery
 */
export const loginRecoverPasswordHtmlContentMutation = (options?: Partial<Options<LoginRecoverPasswordHtmlContentData>>): UseMutationOptions<LoginRecoverPasswordHtmlContentResponse, AxiosError<LoginRecoverPasswordHtmlContentError>, Options<LoginRecoverPasswordHtmlContentData>> => {
    const mutationOptions: UseMutationOptions<LoginRecoverPasswordHtmlContentResponse, AxiosError<LoginRecoverPasswordHtmlContentError>, Options<LoginRecoverPasswordHtmlContentData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await Login.recoverPasswordHtmlContent({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const usersReadUsersQueryKey = (options?: Options<UsersReadUsersData>) => createQueryKey('usersReadUsers', options);

/**
 * Read Users
 * Retrieve users.
 */
export const usersReadUsersOptions = (options?: Options<UsersReadUsersData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await Users.readUsers({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: usersReadUsersQueryKey(options)
    });
};

export const usersCreateUserQueryKey = (options: Options<UsersCreateUserData>) => createQueryKey('usersCreateUser', options);

/**
 * Create User
 * Create new user.
 */
export const usersCreateUserOptions = (options: Options<UsersCreateUserData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await Users.createUser({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: usersCreateUserQueryKey(options)
    });
};

/**
 * Create User
 * Create new user.
 */
export const usersCreateUserMutation = (options?: Partial<Options<UsersCreateUserData>>): UseMutationOptions<UsersCreateUserResponse, AxiosError<UsersCreateUserError>, Options<UsersCreateUserData>> => {
    const mutationOptions: UseMutationOptions<UsersCreateUserResponse, AxiosError<UsersCreateUserError>, Options<UsersCreateUserData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await Users.createUser({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete User Me
 * Delete own user.
 */
export const usersDeleteUserMeMutation = (options?: Partial<Options<UsersDeleteUserMeData>>): UseMutationOptions<UsersDeleteUserMeResponse, AxiosError<DefaultError>, Options<UsersDeleteUserMeData>> => {
    const mutationOptions: UseMutationOptions<UsersDeleteUserMeResponse, AxiosError<DefaultError>, Options<UsersDeleteUserMeData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await Users.deleteUserMe({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const usersReadUserMeQueryKey = (options?: Options<UsersReadUserMeData>) => createQueryKey('usersReadUserMe', options);

/**
 * Read User Me
 * Get current user.
 */
export const usersReadUserMeOptions = (options?: Options<UsersReadUserMeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await Users.readUserMe({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: usersReadUserMeQueryKey(options)
    });
};

/**
 * Update User Me
 * Update own user.
 */
export const usersUpdateUserMeMutation = (options?: Partial<Options<UsersUpdateUserMeData>>): UseMutationOptions<UsersUpdateUserMeResponse, AxiosError<UsersUpdateUserMeError>, Options<UsersUpdateUserMeData>> => {
    const mutationOptions: UseMutationOptions<UsersUpdateUserMeResponse, AxiosError<UsersUpdateUserMeError>, Options<UsersUpdateUserMeData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await Users.updateUserMe({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update Password Me
 * Update own password.
 */
export const usersUpdatePasswordMeMutation = (options?: Partial<Options<UsersUpdatePasswordMeData>>): UseMutationOptions<UsersUpdatePasswordMeResponse, AxiosError<UsersUpdatePasswordMeError>, Options<UsersUpdatePasswordMeData>> => {
    const mutationOptions: UseMutationOptions<UsersUpdatePasswordMeResponse, AxiosError<UsersUpdatePasswordMeError>, Options<UsersUpdatePasswordMeData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await Users.updatePasswordMe({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const usersRegisterUserQueryKey = (options: Options<UsersRegisterUserData>) => createQueryKey('usersRegisterUser', options);

/**
 * Register User
 * Create new user without the need to be logged in.
 */
export const usersRegisterUserOptions = (options: Options<UsersRegisterUserData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await Users.registerUser({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: usersRegisterUserQueryKey(options)
    });
};

/**
 * Register User
 * Create new user without the need to be logged in.
 */
export const usersRegisterUserMutation = (options?: Partial<Options<UsersRegisterUserData>>): UseMutationOptions<UsersRegisterUserResponse, AxiosError<UsersRegisterUserError>, Options<UsersRegisterUserData>> => {
    const mutationOptions: UseMutationOptions<UsersRegisterUserResponse, AxiosError<UsersRegisterUserError>, Options<UsersRegisterUserData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await Users.registerUser({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete User
 * Delete a user.
 */
export const usersDeleteUserMutation = (options?: Partial<Options<UsersDeleteUserData>>): UseMutationOptions<UsersDeleteUserResponse, AxiosError<UsersDeleteUserError>, Options<UsersDeleteUserData>> => {
    const mutationOptions: UseMutationOptions<UsersDeleteUserResponse, AxiosError<UsersDeleteUserError>, Options<UsersDeleteUserData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await Users.deleteUser({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const usersReadUserByIdQueryKey = (options: Options<UsersReadUserByIdData>) => createQueryKey('usersReadUserById', options);

/**
 * Read User By Id
 * Get a specific user by id.
 */
export const usersReadUserByIdOptions = (options: Options<UsersReadUserByIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await Users.readUserById({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: usersReadUserByIdQueryKey(options)
    });
};

/**
 * Update User
 * Update a user.
 */
export const usersUpdateUserMutation = (options?: Partial<Options<UsersUpdateUserData>>): UseMutationOptions<UsersUpdateUserResponse, AxiosError<UsersUpdateUserError>, Options<UsersUpdateUserData>> => {
    const mutationOptions: UseMutationOptions<UsersUpdateUserResponse, AxiosError<UsersUpdateUserError>, Options<UsersUpdateUserData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await Users.updateUser({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const utilsTestEmailQueryKey = (options: Options<UtilsTestEmailData>) => createQueryKey('utilsTestEmail', options);

/**
 * Test Email
 * Test emails.
 */
export const utilsTestEmailOptions = (options: Options<UtilsTestEmailData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await Utils.testEmail({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: utilsTestEmailQueryKey(options)
    });
};

/**
 * Test Email
 * Test emails.
 */
export const utilsTestEmailMutation = (options?: Partial<Options<UtilsTestEmailData>>): UseMutationOptions<UtilsTestEmailResponse, AxiosError<UtilsTestEmailError>, Options<UtilsTestEmailData>> => {
    const mutationOptions: UseMutationOptions<UtilsTestEmailResponse, AxiosError<UtilsTestEmailError>, Options<UtilsTestEmailData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await Utils.testEmail({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const utilsHealthCheckQueryKey = (options?: Options<UtilsHealthCheckData>) => createQueryKey('utilsHealthCheck', options);

/**
 * Health Check
 */
export const utilsHealthCheckOptions = (options?: Options<UtilsHealthCheckData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await Utils.healthCheck({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: utilsHealthCheckQueryKey(options)
    });
};

export const itemsReadItemsQueryKey = (options?: Options<ItemsReadItemsData>) => createQueryKey('itemsReadItems', options);

/**
 * Read Items
 * Retrieve items.
 */
export const itemsReadItemsOptions = (options?: Options<ItemsReadItemsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await Items.readItems({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: itemsReadItemsQueryKey(options)
    });
};

export const itemsCreateItemQueryKey = (options: Options<ItemsCreateItemData>) => createQueryKey('itemsCreateItem', options);

/**
 * Create Item
 * Create new item.
 */
export const itemsCreateItemOptions = (options: Options<ItemsCreateItemData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await Items.createItem({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: itemsCreateItemQueryKey(options)
    });
};

/**
 * Create Item
 * Create new item.
 */
export const itemsCreateItemMutation = (options?: Partial<Options<ItemsCreateItemData>>): UseMutationOptions<ItemsCreateItemResponse, AxiosError<ItemsCreateItemError>, Options<ItemsCreateItemData>> => {
    const mutationOptions: UseMutationOptions<ItemsCreateItemResponse, AxiosError<ItemsCreateItemError>, Options<ItemsCreateItemData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await Items.createItem({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Item
 * Delete an item.
 */
export const itemsDeleteItemMutation = (options?: Partial<Options<ItemsDeleteItemData>>): UseMutationOptions<ItemsDeleteItemResponse, AxiosError<ItemsDeleteItemError>, Options<ItemsDeleteItemData>> => {
    const mutationOptions: UseMutationOptions<ItemsDeleteItemResponse, AxiosError<ItemsDeleteItemError>, Options<ItemsDeleteItemData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await Items.deleteItem({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const itemsReadItemQueryKey = (options: Options<ItemsReadItemData>) => createQueryKey('itemsReadItem', options);

/**
 * Read Item
 * Get item by ID.
 */
export const itemsReadItemOptions = (options: Options<ItemsReadItemData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await Items.readItem({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: itemsReadItemQueryKey(options)
    });
};

/**
 * Update Item
 * Update an item.
 */
export const itemsUpdateItemMutation = (options?: Partial<Options<ItemsUpdateItemData>>): UseMutationOptions<ItemsUpdateItemResponse, AxiosError<ItemsUpdateItemError>, Options<ItemsUpdateItemData>> => {
    const mutationOptions: UseMutationOptions<ItemsUpdateItemResponse, AxiosError<ItemsUpdateItemError>, Options<ItemsUpdateItemData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await Items.updateItem({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const privateCreateUserQueryKey = (options: Options<PrivateCreateUserData>) => createQueryKey('privateCreateUser', options);

/**
 * Create User
 * Create a new user.
 */
export const privateCreateUserOptions = (options: Options<PrivateCreateUserData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await Private.createUser({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: privateCreateUserQueryKey(options)
    });
};

/**
 * Create User
 * Create a new user.
 */
export const privateCreateUserMutation = (options?: Partial<Options<PrivateCreateUserData>>): UseMutationOptions<PrivateCreateUserResponse, AxiosError<PrivateCreateUserError>, Options<PrivateCreateUserData>> => {
    const mutationOptions: UseMutationOptions<PrivateCreateUserResponse, AxiosError<PrivateCreateUserError>, Options<PrivateCreateUserData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await Private.createUser({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};